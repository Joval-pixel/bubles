<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bolhas 3D - Exemplo</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0a0a0a;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
        }
        
        .bubble-label {
            position: absolute;
            color: white;
            font-weight: bold;
            text-align: center;
            pointer-events: none;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="info">
            <h3>Bolhas 3D - Demonstração</h3>
            <p>Clique e arraste para rotacionar</p>
            <p>Scroll para zoom</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        // Configuração da cena
        let scene, camera, renderer, controls;
        let bubbles = [];
        let mouseX = 0, mouseY = 0;
        
        // Dados de exemplo (similar ao bubles.com.br)
        const stockData = [
            { symbol: 'PETR4', name: 'Petrobras', change: 2.5, value: 32.45, size: 80 },
            { symbol: 'VALE3', name: 'Vale', change: -1.2, value: 65.30, size: 70 },
            { symbol: 'ITUB4', name: 'Itaú', change: 0.8, value: 28.90, size: 60 },
            { symbol: 'BBDC4', name: 'Bradesco', change: -0.5, value: 15.20, size: 55 },
            { symbol: 'ABEV3', name: 'Ambev', change: 1.8, value: 12.80, size: 50 },
            { symbol: 'MGLU3', name: 'Magazine Luiza', change: -3.2, value: 8.45, size: 45 },
            { symbol: 'WEGE3', name: 'WEG', change: 2.1, value: 45.60, size: 40 },
            { symbol: 'RENT3', name: 'Localiza', change: 0.3, value: 52.30, size: 35 },
            { symbol: 'LREN3', name: 'Lojas Renner', change: -1.8, value: 18.70, size: 30 },
            { symbol: 'JBSS3', name: 'JBS', change: 1.5, value: 35.20, size: 25 }
        ];

        function init() {
            // Cena
            scene = new THREE.Scene();
            
            // Câmera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 200;
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x0a0a0a, 1);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Controles
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enableZoom = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;
            
            // Iluminação
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(100, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            const pointLight = new THREE.PointLight(0x4080ff, 0.3, 300);
            pointLight.position.set(-50, 50, 100);
            scene.add(pointLight);
            
            // Criar bolhas
            createBubbles();
            
            // Event listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousemove', onMouseMove);
            
            // Iniciar animação
            animate();
        }
        
        function createBubbles() {
            stockData.forEach((stock, index) => {
                const bubble = createBubble(stock, index);
                bubbles.push(bubble);
                scene.add(bubble.mesh);
            });
        }
        
        function createBubble(stock, index) {
            const radius = stock.size / 2;
            const geometry = new THREE.SphereGeometry(radius, 32, 32);
            
            // Cor baseada na variação
            const isPositive = stock.change >= 0;
            const intensity = Math.min(Math.abs(stock.change) / 5, 1);
            
            let color;
            if (isPositive) {
                color = new THREE.Color().setHSL(0.33, 0.8, 0.3 + intensity * 0.4); // Verde
            } else {
                color = new THREE.Color().setHSL(0, 0.8, 0.3 + intensity * 0.4); // Vermelho
            }
            
            // Material com gradiente e brilho
            const material = new THREE.MeshPhongMaterial({
                color: color,
                shininess: 100,
                specular: 0x222222,
                transparent: true,
                opacity: 0.9
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            
            // Posição inicial
            const angle = (index / stockData.length) * Math.PI * 2;
            const distance = 80 + Math.random() * 40;
            mesh.position.x = Math.cos(angle) * distance;
            mesh.position.y = Math.sin(angle) * distance;
            mesh.position.z = (Math.random() - 0.5) * 100;
            
            // Sombra
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            // Criar label HTML
            const label = createLabel(stock);
            
            return {
                mesh: mesh,
                label: label,
                data: stock,
                originalPosition: mesh.position.clone(),
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.1
                )
            };
        }
        
        function createLabel(stock) {
            const label = document.createElement('div');
            label.className = 'bubble-label';
            label.innerHTML = `
                <div style="font-size: ${Math.max(10, stock.size / 4)}px;">
                    <strong>${stock.symbol}</strong><br>
                    <span style="font-size: 0.8em;">${stock.change >= 0 ? '+' : ''}${stock.change.toFixed(1)}%</span>
                </div>
            `;
            document.getElementById('container').appendChild(label);
            return label;
        }
        
        function updateLabels() {
            bubbles.forEach(bubble => {
                const vector = bubble.mesh.position.clone();
                vector.project(camera);
                
                const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (vector.y * -0.5 + 0.5) * window.innerHeight;
                
                bubble.label.style.left = (x - 30) + 'px';
                bubble.label.style.top = (y - 15) + 'px';
                
                // Ocultar labels que estão atrás
                bubble.label.style.display = vector.z > 1 ? 'none' : 'block';
            });
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Atualizar controles
            controls.update();
            
            // Animação das bolhas
            bubbles.forEach(bubble => {
                // Movimento suave
                bubble.mesh.position.add(bubble.velocity);
                
                // Rotação
                bubble.mesh.rotation.x += 0.005;
                bubble.mesh.rotation.y += 0.01;
                
                // Limites da tela (bounce)
                if (Math.abs(bubble.mesh.position.x) > 150) {
                    bubble.velocity.x *= -0.8;
                }
                if (Math.abs(bubble.mesh.position.y) > 100) {
                    bubble.velocity.y *= -0.8;
                }
                if (Math.abs(bubble.mesh.position.z) > 80) {
                    bubble.velocity.z *= -0.8;
                }
                
                // Atração ao centro (suave)
                const centerForce = bubble.mesh.position.clone().multiplyScalar(-0.001);
                bubble.velocity.add(centerForce);
                
                // Damping
                bubble.velocity.multiplyScalar(0.99);
            });
            
            // Atualizar labels
            updateLabels();
            
            // Render
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function onMouseMove(event) {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Efeito de repulsão do mouse
            bubbles.forEach(bubble => {
                const mouseVector = new THREE.Vector3(mouseX * 100, mouseY * 100, 0);
                const distance = bubble.mesh.position.distanceTo(mouseVector);
                
                if (distance < 50) {
                    const repulsion = bubble.mesh.position.clone().sub(mouseVector).normalize().multiplyScalar(0.5);
                    bubble.velocity.add(repulsion);
                }
            });
        }
        
        // Inicializar quando a página carregar
        window.addEventListener('load', init);
    </script>
</body>
</html>
